---
title: OAuth2 Integration Guide
description: OAuth2 allows third-party applications to access users' MindVerse data after authorization
---

OAuth2 allows third-party applications to access users' MindVerse data after authorization. This guide explains how to implement the standard authorization code flow.

## Overview

SecondMe API uses the standard OAuth2 Authorization Code Flow:

1. User is redirected to MindVerse authorization page
2. User confirms authorization
3. MindVerse returns authorization code to your application
4. Your application exchanges the code for Access Token
5. Use Access Token to call APIs

## Prerequisites

Before you begin, you need to:

1. Register your application in MindVerse Developer Console
2. Obtain `client_id` and `client_secret`
3. Configure callback URL (Redirect URI)

## Token Types and Validity

| Token Type | Prefix | Validity |
|------------|--------|----------|
| Authorization Code | `lba_ac_` | 5 minutes |
| Access Token | `lba_at_` | 2 hours |
| Refresh Token | `lba_rt_` | 30 days |

## Authorization Flow

### Step 1: Initiate Authorization Request

Guide the user to the SecondMe authorization page for login and authorization.

#### Option A: Frontend Redirect (Recommended)

For web applications, we recommend using the standard OAuth2 redirect approach. Redirect the user to the SecondMe authorization page:

```
https://go.second.me/oauth/?client_id=YOUR_CLIENT_ID&redirect_uri=YOUR_REDIRECT_URI&response_type=code&state=RANDOM_STATE
```

**Authorization URL Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| client_id | string | Yes | Application's Client ID |
| redirect_uri | string | Yes | Callback URL after authorization, must match app configuration |
| response_type | string | Yes | Fixed value `code` |
| state | string | Yes | CSRF protection parameter, use a random string |

**Frontend Example Code:**

```javascript
// Build authorization URL
function buildAuthorizationUrl() {
  const params = new URLSearchParams({
    client_id: 'your_client_id',
    redirect_uri: 'https://your-app.com/callback',
    response_type: 'code',
    state: generateRandomState()  // Generate and store random state for verification
  });
  return `https://go.second.me/oauth/?${params.toString()}`;
}

// Initiate authorization - Option 1: Direct redirect
window.location.href = buildAuthorizationUrl();

// Initiate authorization - Option 2: Open in new window
window.open(buildAuthorizationUrl(), '_blank');
```

After the user completes login and authorization on SecondMe, they will be redirected back to your `redirect_uri` with the authorization code in the URL:

```
https://your-app.com/callback?code=lba_ac_xxxxx...&state=your_state
```

> **Important**: Upon receiving the callback, always verify that the `state` parameter matches the value stored when initiating the request to prevent CSRF attacks.

#### Option B: Server-side Direct Call (For scenarios with existing user session)

If your server already has the user's login session (Bearer Token), you can directly call the authorization endpoint:

```bash
curl -X POST "https://app.mindos.com/gate/lab/api/oauth/authorize/external" \
  -H "Authorization: Bearer <user_token>" \
  -H "Content-Type: application/json" \
  -d '{
    "clientId": "your_client_id",
    "redirectUri": "https://your-app.com/callback",
    "scope": ["user.info", "chat"],
    "state": "random_state_for_csrf_protection"
  }'
```

**Request Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| clientId | string | Yes | Application's Client ID |
| redirectUri | string | Yes | Callback URL after authorization |
| scope | string[] | Yes | List of requested permissions |
| state | string | No | CSRF protection parameter, recommended |

**Success Response:**

```json
{
  "code": 0,
  "data": {
    "code": "lba_ac_xxxxx...",
    "state": "random_state_for_csrf_protection"
  }
}
```

### Step 2: Exchange Code for Token

After receiving the authorization code, exchange it for Access Token on your server:

```bash
curl -X POST "https://app.mindos.com/gate/lab/api/oauth/token/code" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=authorization_code" \
  -d "code=lba_ac_xxxxx..." \
  -d "redirect_uri=https://your-app.com/callback" \
  -d "client_id=your_client_id" \
  -d "client_secret=your_client_secret"
```

**Request Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| grant_type | string | Yes | Fixed value `authorization_code` |
| code | string | Yes | Authorization code from Step 1 |
| redirect_uri | string | Yes | Must match the value in Step 1 |
| client_id | string | Yes | Application's Client ID |
| client_secret | string | Yes | Application's Client Secret |

**Success Response:**

```json
{
  "code": 0,
  "data": {
    "accessToken": "lba_at_xxxxx...",
    "refreshToken": "lba_rt_xxxxx...",
    "tokenType": "Bearer",
    "expiresIn": 7200,
    "scope": ["user.info", "chat"]
  }
}
```

### Step 3: Use Access Token

Use the Access Token in API requests:

```bash
curl -X GET "https://app.mindos.com/gate/lab/api/secondme/user/info" \
  -H "Authorization: Bearer lba_at_xxxxx..."
```

### Step 4: Refresh Access Token

When the Access Token expires, use the Refresh Token to get a new one:

```bash
curl -X POST "https://app.mindos.com/gate/lab/api/oauth/token/refresh" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=lba_rt_xxxxx..." \
  -d "client_id=your_client_id" \
  -d "client_secret=your_client_secret"
```

**Request Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| grant_type | string | Yes | Fixed value `refresh_token` |
| refresh_token | string | Yes | Previously obtained Refresh Token |
| client_id | string | Yes | Application's Client ID |
| client_secret | string | Yes | Application's Client Secret |

**Success Response:**

```json
{
  "code": 0,
  "data": {
    "accessToken": "lba_at_new_token...",
    "refreshToken": "lba_rt_new_token...",
    "tokenType": "Bearer",
    "expiresIn": 7200,
    "scope": ["user.info", "chat"]
  }
}
```

> **Note**: Token refresh also rotates the Refresh Token. The old Refresh Token becomes invalid.

## Permissions (Scope)

You need to specify permission list when requesting authorization. Users can see the permissions your application requests and decide whether to authorize.

| Scope | Description |
|-------|-------------|
| `user.info` | Access user's basic info (name, email, avatar, etc.) |
| `user.info.shades` | Access user's interest tags |
| `user.info.softmemory` | Access user's soft memories |
| `note.add` | Add notes and memories |
| `chat` | Access chat functionality |

**Best Practice**: Only request necessary permissions to avoid users rejecting authorization due to excessive permission requests.

## Error Handling

### Invalid or Expired Authorization Code

```json
{
  "code": 400,
  "message": "Authorization code is invalid or expired",
  "subCode": "oauth2.code.invalid"
}
```

### Client Secret Mismatch

```json
{
  "code": 401,
  "message": "Client Secret does not match",
  "subCode": "oauth2.client.secret_mismatch"
}
```

### Redirect URI Mismatch

```json
{
  "code": 400,
  "message": "Redirect URI does not match",
  "subCode": "oauth2.redirect_uri.mismatch"
}
```

### Access Token Expired

```json
{
  "code": 401,
  "message": "Access Token has expired",
  "subCode": "oauth2.token.expired"
}
```

## Security Best Practices

### 1. Protect Client Secret

Client Secret must be kept confidential and used only server-side. Never expose it in client-side code.

### 2. Use State Parameter

Always use the `state` parameter to prevent CSRF attacks:

```python
import secrets

# Generate random state
state = secrets.token_urlsafe(32)
# Store in session
session['oauth_state'] = state

# Verify on callback
if request.args.get('state') != session.get('oauth_state'):
    raise SecurityError("State mismatch")
```

### 3. Validate Redirect URI

Ensure Redirect URI uses HTTPS and is registered in the Developer Console.

### 4. Store Tokens Securely

- Encrypt tokens when storing server-side
- Never log tokens
- Set appropriate expiration times

## Next Steps

- [OAuth2 API Reference](/en/docs/api-reference/oauth) - View complete API specifications
- [SecondMe API Reference](/en/docs/api-reference/secondme) - Explore available API endpoints
- [Error Codes Reference](/en/docs/errors) - Understand all error codes
